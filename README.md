# Assertions
Assertions is a framework for simplifying the development proccess of C++ applications.

Currently, Assertions has functionality to help write tests and benchmarks and to generate builds for the project. 

#### Table of Contents
* [The project file tree](#the-project-file-tree)
* [Running tests](#running-tests)
* [Building the Project](#building-the-project)
* [Writing Tests](#writing-tests)
	* [Test case block](#test-case-block)
	* [Asserting values](#asserting-values)
	* [Weird build errors](#weird-build-errors)
* [Writing benchmarks](#writing-benchmarks)
	* [Registering observers](#registering-observers)
	* [Observing variables](#observing-variables)
		* [Observation modes](#observation-modes)
	* [Benchmark block](#benchmark-block)

## The project file tree
Assertions is build with a predefined file tree. Some folders of this tree can be changed by editing _CMakeLists.txt_, _build.sh_ and _test.sh_. The project tree is as follows:
* _build.sh_: script for building the project
* _build_: folder containing all build files generated by _build.sh_
* _src_: folder containing the source files of the project
	* _main_: contains source files which have an entry point. These files will be built as executables inside _build_
	* _objs_: contains headers and source files that have no entry point. This folder is added to your includes search path and source files contained here are used when building tests and _main_ executables
* _test.sh_: script for executing tests
* _tests_: folder containing all tests source files. Cannot be changed without also changing _test.sh_ 

## Running tests
To run already written tests, the _test.sh_ script should be run. Tests are automatically built if needed. The usage of the script is the following: 
```
./test.sh [all] | [space separated list of test names]
```
With the paramater _all_, all tests inside _tests_ are executed.

A test name can be one of the following:
* The name of a source file inside _tests_. Eg: test_something.cpp;
* The name of a source file inside _tests_ without the _test\__ prefix and _.cpp_ extension. Eg: something;
* The name of a test binary inside _build_. Eg: test_something;

Usage examples:
```
./test.sh
./test.sh all
```
Both will run all tests
```
./test.sh something
./test.sh test_something
./test.sh test_something.cpp
```
All three will run the test written in _tests/test\_something.cpp_

Alternatively the test binaries can also be run directly but the output will not have as much information as when run from the script.

Tests can also be run using CTest, but the entire test file will be considered a single test as opposed to each test case being its own individual test.

## Building the project
Assertions provides the script _build.sh_ for building code. Usage:
```
./build.sh [target] | [clean] | [cmake-only]
```
* _target_: Makefile target that should be built. With the default CMakeLists this will be the name of binary to be generated in _build_
* _clean_: Delete all build files
* _cmake-only_: Execute cmake but do not build the binaries

If no option is passed then all possible targets are built

## Writing tests
First step for writing a test is creating a _.cpp_ file with the _test\__ prefix inside the _tests_ folder.

The tests should be written inside a _main_ function. The main function does not need to return anything and does not take any arguments.

### Test case block
A test case block is a block specifing something to be tested. A test block must contain a message describing what is going to be tested. Eg:
```
test_case("whether this functionality works") {
	// test code goes here
} end_test_case;
```

### Asserting values
Assert macros ensure that a test condition is met and if not will cause the test case to fail. The first value is the value to be tested and the second value is the target value.
 
#### assert\_equal
Checks if a value equals the target 
```
test_case("a equals 2") {
	int a = 2;
	assert_equal(a, 2);
} end_test_case;
```

#### assert\_not\_equal
Checks if a value is different from the target
```
test_case("a not equal 2") {
        int a = 3;
        assert_not_equal(a, 2);
} end_test_case;
```

#### assert\_greater\_than
Checks if a value is greater than the target
```
test_case("a greater than 2") {
        int a = 3;
        assert_greater_than(a, 2);
} end_test_case;
```

#### assert\_less\_than
Checks if a value is less than the target 
```
test_case("a less than 2") {
        int a = 1;
        assert_less_than(a, 2);
} end_test_case;
```

#### assert\_greater\_than\_or\_equal
Checks if a value is greater than or equal the target
```
test_case("a greater than or equal 1") {
        int a = 2;
        assert_greater_than_or_equal(a, 2);
	assert_greater_than_or_equal(a, 1);
} end_test_case;
```

#### assert\_less\_than\_or\_equal
Checks if a value is less than or equal the target
```
test_case("a less than or equal 1") {
        int a = 1;
        assert_less_than_or_equal(a, 2);
	assert_less_than_or_equal(a, 1);
} end_test_case;
```

#### assert\_true
Checks if a logic expression is true. Useful for doing more complex assertions
```
test_case("a in range [0, 3)") {
        int a = 2;
        assert_true(a >= 0 && a < 3);
} end_test_case;
```

### Weird build errors
Assertions makes heavy use of macros in order to generate code during compilation time. This means that if a test is badly written you will get compilation error messages referencing code you did not write explicitly. Eg:
```
int main (void) {
	test_case("missing brackets")
		assert_true(true);
	end_test_case;
}
```
The compiler will complain near a "try" keyword. Although you did not write this keyword anywhere, it is created during the expansion for the _test\_case_ macro

## Writing benchmarks
Benchmakrs are used for analyzing performance aspects of the code beyond just execution time. A piece of code can be run multiple times with variables being fed to an observer for either human or automated analysis.

A complete example of the usage of the benchmark functionality is available in [benchmark_counter.cpp](src/main/benchmark_counter.cpp)

### Registering observers
Observers are entities which observe the values stored in variables and outputs those values somewhere so that they can be read by a human or by another program. Currently assertions offers these observers:
* TerminalObserver: displays latest variable values to stdout. Requires no parameters
* TextFileObserver: outputs values of each run in human readable format for later analysis. Requires a string containing the path for the output file

Observers are registered with the function _register\_observer_:
```
benchmark::register_observer(new TerminalObserver());
benchmark::register_observer(new TextFileObserver("benchmark_results.txt"));
```

_register\_observer_ requires a pointer due to C++ abstract class constraints. If the observers are instantiated directly inside the function call, the function _delete\_observers_ can be used to automatically delete all previously registered observers:
```
benchmark::delete_observers();
```

### Observing variables
By default, observers will always output total execution time and run number. Other variables can be added by using the function _observe\_variable(variable\_label, variable, observation\_mode)_:
```
int x;
int y;
int z;
benchmark::observe_variable("value of the x variable", x);
benchmark::observe_variable("y", y, benchmark::observation_mode::AVERAGE_VALUE);
benchmark::observe_variable("z", z, benchmark::observation_mode::CURRENT_VALUE | benchmark::observation_mode::AVERAGE_VALUE);
```

Note that variable observation was made with primitives in mind and classes will need to implement various operators in order to be compatible with this feature - see all classes implementing the ObservableVariable interface in [observer.h](src/objs/assertions/observer.h) for a full view of the necessary operators.

#### Observation modes
Observation modes tell observers what information to observe from the variables.

Multiple observation modes can be defined for a single variable by using the bitwise or operator ("|"). If no observation mode is defined, the _CURRENT\_VALUE_ mode will be used.

* _CURRENT\_VALUE_: observe the value of the variable at the end of each run
* _AVERAGE\_VALUE_: observe the average value of the variable throughout all runs

### Benchmark block
After observers have been registered and (optionally) variables have been set to be observed, a benchmark block is used to execute a piece of code _n_ times:
```
unsigned n = 100;
benchmark("execute this code 100 times", n) {
	x = some_performance_critical_function();
	y = some_other_performance_critical_function();
} end_benchmark;
```
This piece of code will execute two performance critical functions 100 times. All registered observers are notified of updates after every loop.
